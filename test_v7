# MCP v7 — Test Report & Repair Prompt (R3)

> **Zweck**: Dieses Dokument ist ein Prompt für **Claude Code**. Es enthält alle Fehler, die beim Live-Test auf dem Server (Commit `beddfc7`, Branch `r2-test`) gefunden wurden, plus Optimierungsvorschläge. Claude Code soll den Code reparieren, **ohne** die funktionierenden Teile zu beschädigen.

> **Datum**: 19.02.2026  
> **Getestet auf**: WSL2 Ubuntu, Docker 27.x, 15 GB RAM, kein GPU  
> **Testbasis**: `make test` → Smoke 33/33 PASS, AI Pipeline 5/5 PASS, Security 5/5 PASS  
> **Alle 33 Container starten und sind healthy/running.**

---

## Übersicht: Was funktioniert ✅

- Installation (`mcp-install.sh --clean`) läuft komplett durch (alle 7 Phasen)
- Alle 5 Docker-Netzwerke + 20 Volumes werden erstellt
- Alle 33 Container starten erfolgreich
- `make test` → **0 FAIL** (Smoke, AI Pipeline, Security)
- Dashboard (/) → 200 OK, zeigt alle 13 Kacheln
- Folgende Dashboard-Links funktionieren korrekt:
  - `/auth/` → 302 (Keycloak) ✅
  - `/grafana/` → 302 (Grafana) ✅
  - `/guac/` → 200 (Guacamole) ✅
  - `/monitor/` → 200 (Zabbix) ✅
  - `/notify/` → 200 (ntfy) ✅
  - `/wiki/` → 302 (BookStack) ✅
  - `/tickets/` → 200 (Zammad) ✅
  - `/remote/` → 302 (MeshCentral) ✅
  - `/status/` → 302 (Uptime Kuma) ✅
  - `/vault/` → 200 (Vaultwarden) ✅

---

## FEHLER — Severity A (Muss repariert werden)

### A1: `/auto/` → 404 (n8n Subpath-Routing kaputt)

**Datei**: `config/nginx/conf.d/default.conf`  
**Zeilen**: ca. 53-68 (location /auto/)

**Symptom**:
- `curl -sI http://127.0.0.1/auto/` → **404 Not Found** (Content-Type: text/html; charset=utf-8, Length: 145)
- Dashboard-Kachel "n8n" → 404

**Beweis (Upstream funktioniert!)**:
- `docker exec mcp-nginx sh -lc "wget -S -O- http://mcp-n8n:5678/auto 2>&1"` → **200 OK**
- `docker exec mcp-nginx sh -lc "wget -S -O- http://mcp-n8n:5678/auto/ 2>&1"` → **200 OK**
- n8n ist healthy, Container mcp-n8n läuft, Port 5678 offen

**Root Cause**:
Die 404 kommt von n8n selbst (nicht von nginx). nginx leitet den Request korrekt weiter, aber der Pfad wird falsch übergeben. Die aktuelle Config:
```nginx
location = /auto { return 301 /auto/; }
location /auto/ {
    set $upstream_n8n http://n8n:5678;
    proxy_pass $upstream_n8n;
    # ... headers ...
}
```
Problem: `proxy_pass $upstream_n8n;` ohne URI → nginx sendet den vollständigen Original-Pfad `/auto/` an n8n. Obwohl n8n mit `N8N_PATH=/auto` konfiguriert ist, scheint die Kombination aus Variable-basiertem upstream (`set $upstream`) und ohne explizite URI dazu zu führen, dass n8n den Request nicht korrekt matched.

**Zusätzliches Problem**: n8n hat **kein** `N8N_EDITOR_BASE_URL` gesetzt, was für korrektes Subpath-Routing wichtig ist.

**Fix-Anweisung**:
1. In `config/nginx/conf.d/default.conf`: Den /auto/ location-Block so ändern, dass der Pfad-Prefix gestrippt und an n8n als `/` weitergeleitet wird (gleich wie bei `/notify/`, `/tickets/`, `/wiki/` — die alle funktionieren und `rewrite ^/prefix/(.*) /$1 break;` verwenden):
```nginx
location = /auto { return 301 /auto/; }
location /auto/ {
    set $upstream_n8n http://n8n:5678;
    rewrite ^/auto/(.*) /$1 break;
    proxy_pass $upstream_n8n;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Prefix /auto;
    proxy_redirect / /auto/;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
}
```

2. In `compose/core/docker-compose.yml`, n8n environment: `N8N_PATH=/auto` entfernen (nicht mehr nötig wenn nginx den Prefix strippt) **ODER** alternativ `N8N_EDITOR_BASE_URL` hinzufügen:
```yaml
N8N_EDITOR_BASE_URL: http://${MCP_HOST_IP}/auto
```
Wichtig: Prüfe ob n8n mit rewrite+strip und OHNE N8N_PATH besser funktioniert (wie alle anderen Services), oder ob N8N_PATH bleiben soll. Das Pattern das bei /notify/, /tickets/, /wiki/ funktioniert, ist: rewrite strip + proxy_redirect.

---

### A2: `/portainer/` → 404 (Portainer Subpath-Routing kaputt)

**Datei**: `config/nginx/conf.d/default.conf`  
**Zeilen**: ca. 157-173 (location /portainer/)  
**Datei 2**: `compose/ops/docker-compose.yml` (Portainer service)

**Symptom**:
- `curl -sI http://127.0.0.1/portainer/` → **404 Not Found** (Content-Type: text/plain; charset=utf-8, Length: 19 = Go "404 page not found")
- Dashboard-Kachel "Portainer" → 404

**Beweis (Upstream-Verhalten)**:
- `docker exec mcp-nginx sh -lc "wget -S -O- http://mcp-portainer:9000/ 2>&1"` → **200 OK** (HTML, 18729 bytes, Portainer UI)
- `docker exec mcp-nginx sh -lc "wget -S -O- http://mcp-portainer:9000/portainer/ 2>&1"` → **404 Not Found**
- `docker inspect mcp-portainer --format '{{json .Config.Cmd}}'` → `["--base-url","/portainer"]`

**Root Cause**:
Portainer ist zwar mit `--base-url /portainer` gestartet, aber die Upstream-Tests beweisen dass Portainer trotzdem **nur auf `/` antwortet** und `/portainer/` mit 404 ablehnt. Das `--base-url` Flag in Portainer CE 2.21.5 ändert nur die internen Links/Redirects der UI, nicht den tatsächlichen Serving-Pfad.

Die aktuelle nginx-Config:
```nginx
location = /portainer { return 301 /portainer/; }
location /portainer/ {
    set $upstream_portainer http://portainer:9000;
    proxy_pass $upstream_portainer;
    # ... kein rewrite ...
}
```
→ nginx sendet `/portainer/` an Portainer → Portainer kennt diesen Pfad nicht → 404.

**Fix-Anweisung**:
1. In `config/nginx/conf.d/default.conf`: Den /portainer/ Block mit `rewrite` und `proxy_redirect` versehen (Prefix strippen, genau wie bei /notify/, /tickets/, /wiki/):
```nginx
location = /portainer { return 301 /portainer/; }
location /portainer/ {
    set $upstream_portainer http://portainer:9000;
    rewrite ^/portainer/(.*) /$1 break;
    proxy_pass $upstream_portainer;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Prefix /portainer;
    proxy_redirect / /portainer/;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
}
```

2. In `compose/ops/docker-compose.yml`: `--base-url /portainer` kann bleiben (schadet nicht, hilft bei internen Portainer-Redirects), aber ist NICHT ausreichend allein.

---

### A3: Portainer Healthcheck ist `["NONE"]`

**Datei**: `compose/ops/docker-compose.yml`  
**Zeile**: ca. 291

**Symptom**:
- `docker ps` zeigt Portainer als "running" statt "healthy"
- Smoke-Test prüft nur `running` statt `healthy` für Portainer

**Aktueller Code**:
```yaml
healthcheck:
  test: ["NONE"]
```

**Fix-Anweisung**:
Ersetze den Healthcheck durch einen funktionierenden HTTP-Check:
```yaml
healthcheck:
  test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:9000/ >/dev/null 2>&1 || exit 1"]
  interval: 30s
  timeout: 10s
  retries: 5
  start_period: 30s
```

---

## FEHLER — Severity B (Sollte repariert werden)

### B1: Makefile filtert auf hardcoded `project=mcp`

**Datei**: `Makefile`  
**Zeilen**: 85, 90

**Symptom**:
- `make ps` und `make logs` zeigen keine Container wenn `COMPOSE_PROJECT_NAME=mcpwsl`
- Die Filter `--filter "label=com.docker.compose.project=mcp"` matchen nicht

**Aktueller Code**:
```makefile
@docker ps --filter "label=com.docker.compose.project=mcp" ...
```

**Fix-Anweisung**:
Ersetze den hardcoded Wert mit einer dynamischen Variable:
```makefile
PROJECT := $(shell grep '^COMPOSE_PROJECT_NAME=' .env 2>/dev/null | cut -d= -f2 || echo "mcp")
# ...
@docker ps --filter "label=com.docker.compose.project=$(PROJECT)" ...
```

---

### B2: mcp-status.sh filtert auf hardcoded `project=mcp`

**Datei**: `scripts/mcp-status.sh`  
**Zeilen**: 120-122

**Symptom**:
- Status-Summary zeigt falsche Zahlen (0 Container) wenn `COMPOSE_PROJECT_NAME != mcp`

**Aktueller Code**:
```bash
total=$(docker ps --filter "label=com.docker.compose.project=mcp" -q 2>/dev/null | wc -l)
```

**Fix-Anweisung**:
Am Anfang des Scripts die Variable aus .env lesen:
```bash
if [ -f .env ]; then set -a; source .env; set +a; fi
PROJECT="${COMPOSE_PROJECT_NAME:-mcp}"
```
Dann alle `project=mcp` ersetzen durch `project=${PROJECT}`.

---

### B3: Keycloak deprecated Environment Variables

**Datei**: `compose/core/docker-compose.yml`  
**Zeilen**: Keycloak environment section

**Symptom (Log-Warning)**:
```
KC-SERVICES0110: Environment variable 'KEYCLOAK_ADMIN' is deprecated, use 'KC_BOOTSTRAP_ADMIN_USERNAME' instead
KC-SERVICES0110: Environment variable 'KEYCLOAK_ADMIN_PASSWORD' is deprecated, use 'KC_BOOTSTRAP_ADMIN_PASSWORD' instead
```

**Fix-Anweisung**:
In der Keycloak environment section:
- `KEYCLOAK_ADMIN` → `KC_BOOTSTRAP_ADMIN_USERNAME`
- `KEYCLOAK_ADMIN_PASSWORD` → `KC_BOOTSTRAP_ADMIN_PASSWORD`

Auch in `.env.example` die Variablennamen anpassen falls dort referenziert.

---

### B4: n8n Permissions Warning

**Datei**: `compose/core/docker-compose.yml`  
**Zeilen**: n8n environment section

**Symptom (Log-Warning)**:
```
Permissions 0644 for n8n settings file /home/node/.n8n/config are too wide.
```

**Fix-Anweisung**:
Füge in der n8n environment section hinzu:
```yaml
N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS: "true"
```

---

### B5: mcp-install.sh Cleanup filtert auf hardcoded `project=mcp`

**Datei**: `scripts/mcp-install.sh`  
**Zeile**: 55

**Aktueller Code**:
```bash
docker ps -a --filter "label=com.docker.compose.project=mcp" ...
```

**Fix-Anweisung**:
Ersetze durch:
```bash
docker ps -a --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME:-mcp}" ...
```

---

## FEHLER — Severity C (Nice-to-have / Kosmetik)

### C1: Grafana location fehlt `proxy_redirect`

**Datei**: `config/nginx/conf.d/default.conf`  
**Zeilen**: Grafana location block

**Symptom**: Grafana funktioniert (302), aber falls Grafana interne Redirects ohne Prefix erzeugt, könnten Links brechen.

**Fix-Anweisung**: Kein akuter Fix nötig, da Grafana mit `GF_SERVER_SERVE_FROM_SUB_PATH` korrekt arbeitet. Aber konsistenzhalber `proxy_set_header X-Forwarded-Prefix /grafana;` hinzufügen (fehlt aktuell).

---

### C2: Portainer Security-Timeout nicht dokumentiert

**Symptom (Log)**:
```
the Portainer instance timed out for security purposes, to re-enable your Portainer instance, you will need to restart Portainer
```

Portainer sperrt sich nach 5 Minuten, wenn kein Admin-Account erstellt wurde.

**Fix-Anweisung**:
In `scripts/mcp-install.sh`, nach Phase 4 (Ops Stack), einen Hinweis ausgeben:
```bash
echo "[INFO]  IMPORTANT: Open http://${MCP_HOST_IP}/portainer/ within 5 minutes to create the admin account"
```

---

## OPTIMIERUNGEN

### O1: Nginx Upstream-Namen konsistent machen

**Aktuell**: nginx verwendet Compose-Service-Namen (`n8n`, `portainer`, `keycloak`) die nur über Docker DNS funktionieren weil alle Netzwerke `external: true` sind.

**Empfehlung**: Das funktioniert korrekt, aber für Debugging-Konsistenz könnten die Upstream-Variablen Kommentare enthalten, die auf den Container-Namen verweisen:
```nginx
set $upstream_n8n http://n8n:5678;  # container: mcp-n8n
```

**Priorität**: Niedrig. Nur Dokumentation.

---

### O2: Dashboard-Link-Test in Smoke-Test aufnehmen

**Datei**: `tests/smoke-test.sh`

**Empfehlung**: Nach dem Container-Health-Check einen HTTP-Check für alle Dashboard-Links hinzufügen:
```bash
echo ""
echo "=== Dashboard HTTP Check ==="
for path in auth auto grafana guac monitor notify portainer remote status tickets vault wiki; do
    code=$(curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1/${path}/" 2>/dev/null || echo "000")
    if [ "$code" = "000" ] || [ "$code" = "404" ] || [ "$code" = "502" ] || [ "$code" = "503" ]; then
        echo -e "  ${RED}[FAIL]${NC} /${path}/ — HTTP $code"
        FAIL=$((FAIL + 1))
    else
        echo -e "  ${GREEN}[PASS]${NC} /${path}/ — HTTP $code"
        PASS=$((PASS + 1))
    fi
done
```

---

### O3: `N8N_EDITOR_BASE_URL` setzen

**Datei**: `compose/core/docker-compose.yml`, n8n environment  
**Datei**: `.env.example`

**Empfehlung**: Füge hinzu:
```yaml
N8N_EDITOR_BASE_URL: http://${MCP_HOST_IP}/auto
```
Das stellt sicher, dass n8n interne Links korrekt mit dem `/auto` Prefix generiert.

---

### O4: Nginx Security-Headers als globaler Block

**Datei**: `config/nginx/conf.d/default.conf`

**Aktuell**: Keine globalen Security-Headers definiert (nur was die Upstream-Services selbst setzen).

**Empfehlung**: Im `server {}` Block global setzen:
```nginx
# Security Headers
add_header X-Frame-Options SAMEORIGIN always;
add_header X-Content-Type-Options nosniff always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Referrer-Policy strict-origin-when-cross-origin always;
```
Dann können die einzelnen location-Blocks diese erben.

---

## ZUSAMMENFASSUNG FÜR CLAUDE CODE

### Dateien die geändert werden müssen:

| # | Datei | Fixes |
|---|-------|-------|
| 1 | `config/nginx/conf.d/default.conf` | A1: /auto/ rewrite+redirect, A2: /portainer/ rewrite+redirect, C1: Grafana Prefix-Header, O4: Security Headers |
| 2 | `compose/ops/docker-compose.yml` | A3: Portainer Healthcheck reparieren |
| 3 | `compose/core/docker-compose.yml` | B3: Keycloak env vars updaten, B4: n8n Permissions-Fix, O3: N8N_EDITOR_BASE_URL |
| 4 | `Makefile` | B1: Dynamischer Projekt-Filter |
| 5 | `scripts/mcp-status.sh` | B2: Dynamischer Projekt-Filter |
| 6 | `scripts/mcp-install.sh` | B5: Dynamischer Projekt-Filter, C2: Portainer-Hinweis |
| 7 | `tests/smoke-test.sh` | O2: Dashboard-HTTP-Check |
| 8 | `.env.example` | B3: Keycloak var-Namen, O3: N8N_EDITOR_BASE_URL |

### Validierung nach dem Fix:

```bash
# 1. Compose Config validieren
for f in compose/*/docker-compose.yml; do
  docker compose --env-file .env -f "$f" config >/dev/null && echo "OK: $f" || echo "FAIL: $f"
done

# 2. Shell-Syntax prüfen
for f in scripts/*.sh tests/*.sh; do
  bash -n "$f" && echo "OK: $f" || echo "FAIL: $f"
done

# 3. Nginx-Syntax prüfen
docker exec mcp-nginx nginx -t

# 4. Dashboard-Links prüfen (ALLE müssen non-404 sein)
for p in auth auto grafana guac monitor notify portainer remote status tickets vault wiki; do
  echo "=== /$p/ ==="
  curl -sI "http://127.0.0.1/$p/" | head -n 3
done

# 5. make test
make test
```

### Wichtige Regeln:

1. **Keine funktionierenden Services kaputt machen** — /auth/, /grafana/, /guac/, /monitor/, /notify/, /wiki/, /tickets/, /remote/, /status/, /vault/ funktionieren alle. Diese Location-Blocks NICHT ändern.
2. **Pattern von funktionierenden Blocks kopieren** — /notify/, /tickets/, /wiki/ verwenden alle `rewrite ^/prefix/(.*) /$1 break;` + `proxy_redirect / /prefix/;`. Dieses Pattern funktioniert bewiesenermaßen. Für /auto/ und /portainer/ dasselbe Pattern verwenden.
3. **Keine Secrets committen** — Nur `.env.example` editieren, nie `.env`
4. **COMPOSE_IGNORE_ORPHANS=1** muss bleiben (verhindert Orphan-Warnings zwischen Stacks)
5. **Test**: Nach dem Fix `make test` ausführen und sicherstellen dass alle Tests weiterhin PASS sind
